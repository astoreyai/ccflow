# ccflow

> Claude Code CLI Middleware - Production Python SDK for Claude Code CLI

ccflow bridges the Claude Code CLI with SDK-like Python interfaces, enabling subscription-based usage (Pro/Max) with TOON token optimization (30-60% savings). Features SDK-compatible agents, hooks, skills, and subagent coordination.

## Quick Facts

- **Version**: 0.2.0
- **Python**: 3.11+
- **License**: MIT
- **Auth**: Uses Claude subscription via CLI OAuth (no API keys needed)
- **Async**: Fully async/await throughout
- **Tests**: 1055+ tests, 86% coverage
- **Modules**: 36 source files, 14.5K LOC
- **Exports**: 215 public symbols

## Installation

```bash
pip install ccflow                    # Basic
pip install "ccflow[toon]"           # With TOON encoding
pip install "ccflow[all]"            # All extras
```

## Core API

### Simple Query
```python
from ccflow import query, CLIAgentOptions

async for msg in query("What is 2+2?", CLIAgentOptions()):
    print(msg.content, end="")
```

### Streaming Query with Model Selection
```python
from ccflow import query, CLIAgentOptions, TextMessage

async for msg in query("Explain AI", CLIAgentOptions(model="sonnet")):
    if isinstance(msg, TextMessage):
        print(msg.content, end="")
```

### Multi-turn Session
```python
from ccflow import Session, CLIAgentOptions

session = Session(options=CLIAgentOptions(model="opus"))
async for msg in session.send_message("Hello!"):
    print(msg.content, end="")
async for msg in session.send_message("What did I say?"):
    print(msg.content, end="")  # Claude remembers
stats = await session.close()
print(f"Total tokens: {stats.total_tokens}")
```

### Batch Processing
```python
from ccflow import batch_query, CLIAgentOptions
results = await batch_query(["Q1", "Q2", "Q3"], CLIAgentOptions(), concurrency=3)
```

### Extended Thinking (Ultrathink)
```python
from ccflow import query, CLIAgentOptions, ThinkingMessage, TextMessage

options = CLIAgentOptions(model="sonnet", ultrathink=True)
async for msg in query("Analyze this complex algorithm", options):
    if isinstance(msg, ThinkingMessage):
        print(f"[Thinking: {msg.thinking_tokens} tokens]")
    elif isinstance(msg, TextMessage):
        print(msg.content, end="")
```

## Agent System (NEW in 0.2.0)

### Define and Execute Agents
```python
from ccflow import Agent, AgentDefinition, AgentRegistry

# Programmatic definition
agent = Agent(AgentDefinition(
    name="code-reviewer",
    description="Reviews code for quality and security",
    prompt="You are a senior code reviewer. Focus on security and best practices.",
    tools=["Read", "Grep", "Glob"],
    model="sonnet",
))

async for msg in agent.execute("Review auth.py for vulnerabilities"):
    print(msg.content, end="")
```

### AgentRegistry with Filesystem Discovery
```python
from ccflow import get_agent_registry

# Auto-discovers from ~/.claude/agents/ and .claude/agents/
registry = get_agent_registry()
agent_names = registry.list()  # ["code-reviewer", "test-runner", ...]
agent = registry.get("code-reviewer")
```

### Agent Definition Files (Markdown + YAML Frontmatter)
```markdown
---
name: code-reviewer
description: Expert code reviewer for quality and security
tools:
  - Read
  - Grep
  - Edit
model: sonnet
---

# Code Reviewer

You are a senior code reviewer specializing in:
- Security vulnerabilities
- Performance issues
- Code maintainability
```

## Hook System (NEW in 0.2.0)

SDK-compatible lifecycle hooks for tool execution and session events.

### 6 Hook Event Types
```python
from ccflow import HookEvent

HookEvent.PRE_TOOL_USE      # Before tool execution
HookEvent.POST_TOOL_USE     # After tool execution
HookEvent.USER_PROMPT_SUBMIT # User submits prompt
HookEvent.STOP              # Agent stops
HookEvent.SUBAGENT_STOP     # Subagent finishes
HookEvent.PRE_COMPACT       # Before context compaction
```

### Register Hooks with Pattern Matching
```python
from ccflow import get_hook_registry, HookEvent, HookContext

hooks = get_hook_registry()

@hooks.on(HookEvent.PRE_TOOL_USE, pattern="Bash.*", priority=10)
async def audit_bash(ctx: HookContext) -> HookContext:
    print(f"Bash command: {ctx.tool_input}")
    return ctx

@hooks.on(HookEvent.POST_TOOL_USE, pattern="Edit|Write")
async def log_edits(ctx: HookContext) -> HookContext:
    print(f"Modified: {ctx.tool_input.get('file_path')}")
    return ctx

@hooks.on(HookEvent.STOP)
async def on_stop(ctx: HookContext) -> HookContext:
    print(f"Session {ctx.session_id} stopped: {ctx.stop_reason}")
    return ctx
```

### Permission Callback
```python
from ccflow import CLIAgentOptions, PermissionResult

async def can_use_tool(tool_name: str, input_data: dict, context) -> PermissionResult:
    if tool_name == "Bash" and "rm" in str(input_data):
        return PermissionResult(behavior="deny", reason="Dangerous command")
    return PermissionResult(behavior="allow")

options = CLIAgentOptions(can_use_tool=can_use_tool)
```

## Skill System (NEW in 0.2.0)

### Load and Match Skills
```python
from ccflow import get_skill_loader

loader = get_skill_loader()

# Semantic matching against query
matched = loader.match("help me review this code")
for skill in matched:
    print(f"Matched: {skill.name} - {skill.description}")

# Direct lookup
skill = loader.get("code-reviewer")
print(skill.instructions)

# Load resources
template = loader.get_resource("code-reviewer", "templates/review.md")
```

### Skill Discovery Paths
```
~/.claude/skills/my-skill/SKILL.md    # User skills
.claude/skills/my-skill/SKILL.md      # Project skills
```

## Subagent Coordination (NEW in 0.2.0)

### Parallel Subagent Execution
```python
from ccflow import get_subagent_coordinator

coordinator = get_subagent_coordinator()

# Parallel execution
results = await coordinator.parallel([
    ("code-reviewer", "Review auth.py"),
    ("security-auditor", "Check for vulnerabilities"),
    ("test-runner", "Run test suite"),
])
for result in results:
    print(result)
```

### Background Tasks
```python
# Spawn in background
task_id = await coordinator.spawn_background("code-reviewer", "Long analysis")

# Check result later
task = await coordinator.get_task_result(task_id, wait=True, timeout=60)
print(task.result)

# Gather all background tasks
all_results = await coordinator.gather(timeout=120)
```

## Custom Tools (NEW in 0.2.0)

### @tool Decorator
```python
from ccflow import tool, create_sdk_mcp_server

@tool(description="Add two numbers")
async def add(a: int, b: int) -> int:
    """Add a and b together."""
    return a + b

@tool(description="Fetch weather data")
async def get_weather(city: str) -> dict:
    """Get current weather for a city."""
    return {"city": city, "temp": 72, "condition": "sunny"}

# Create MCP server from tools
server = create_sdk_mcp_server("my-tools", tools=[add, get_weather])
```

## CLI Commands (NEW in 0.2.0)

### Built-in Commands
```python
from ccflow import get_command_registry

registry = get_command_registry()

# List available agents
result = await registry.execute("agents")

# List skills
result = await registry.execute("skills")

# List hooks
result = await registry.execute("hooks")

# Spawn subagent
result = await registry.execute("spawn", ["code-reviewer", "Review main.py"])

# Get help
result = await registry.execute("help")
```

### Register Custom Commands
```python
@registry.command("greet", "Greet someone", args=["name"])
async def greet(name: str = "World") -> str:
    return f"Hello, {name}!"

# Execute
result = await registry.execute("greet", ["Aaron"])  # "Hello, Aaron!"
```

## Project & Trace Recording

```python
from ccflow import Project, CLIAgentOptions
from ccflow.stores import SQLiteProjectStore, SQLiteTraceStore, SQLiteSessionStore

# Initialize stores
db_path = "ccflow.db"
project = Project(
    name="Code Review",
    store=SQLiteProjectStore(db_path),
    trace_store=SQLiteTraceStore(db_path),
    session_store=SQLiteSessionStore(db_path),
)
await project.save()

# Create traced session
session = project.create_session(
    options=CLIAgentOptions(model="sonnet", ultrathink=True),
    detailed=True,  # Capture message-level stream
)

async for msg in session.send_message("Analyze this function"):
    print(msg.content, end="")

# Access trace
trace = session.last_trace
print(f"Thinking tokens: {trace.thinking_tokens}")
print(f"Tool calls: {len(trace.tool_calls)}")

# Replay with different model
new_session = await project.replay_as_new(
    trace.trace_id,
    options_override=CLIAgentOptions(model="opus"),
)
```

## Architecture

```
┌─────────────────────────────────────────────────────────────────┐
│                    Application Layer                             │
│  query() batch_query() Session Project TracingSession Agent     │
├─────────────────────────────────────────────────────────────────┤
│                    Agent Layer (NEW)                             │
│  AgentRegistry  SkillLoader  SubagentCoordinator  CommandRegistry│
├─────────────────────────────────────────────────────────────────┤
│                    Hook Layer (NEW)                              │
│  HookRegistry  HookMatcher  HookContext  PermissionCallback      │
├─────────────────────────────────────────────────────────────────┤
│                    Middleware Layer                              │
│  SessionManager, StreamParser, EventEmitter, CostTracker        │
├─────────────────────────────────────────────────────────────────┤
│                    Reliability Layer                             │
│  CircuitBreaker, RateLimiter, RetryHandler, HealthChecker       │
├─────────────────────────────────────────────────────────────────┤
│                    Persistence Layer                             │
│  SQLiteSessionStore, SQLiteTraceStore, SQLiteProjectStore       │
├─────────────────────────────────────────────────────────────────┤
│                    Execution Layer                               │
│  CLIExecutor, ProcessPool, StreamingPool                        │
├─────────────────────────────────────────────────────────────────┤
│                    Infrastructure                                │
│  Claude CLI (subprocess with NDJSON streaming)                  │
└─────────────────────────────────────────────────────────────────┘
```

## Module Map (36 Modules)

### Core API
| Module | Purpose | Key Exports |
|--------|---------|-------------|
| `api.py` | High-level query functions | `query()`, `batch_query()` |
| `session.py` | Multi-turn conversations | `Session`, `load_session()` |
| `manager.py` | Session lifecycle | `SessionManager`, `get_manager()` |
| `executor.py` | CLI subprocess handling | `CLIExecutor` |
| `parser.py` | NDJSON stream parsing | `collect_text()`, `collect_thinking()` |

### Agent System (NEW)
| Module | Purpose | Key Exports |
|--------|---------|-------------|
| `agent.py` | Specialized agents | `Agent`, `AgentRegistry`, `AgentDefinition` |
| `skills.py` | Skill discovery | `SkillLoader`, `SkillDefinition` |
| `subagent.py` | Parallel execution | `SubagentCoordinator`, `SubagentTask` |
| `commands.py` | CLI commands | `CommandRegistry`, `CommandDefinition` |

### Hook System (NEW)
| Module | Purpose | Key Exports |
|--------|---------|-------------|
| `hooks.py` | Lifecycle hooks | `HookRegistry`, `HookEvent`, `HookContext` |
| `tools.py` | Custom tools | `tool`, `SdkMcpServer`, `create_sdk_mcp_server()` |

### Types & Configuration
| Module | Purpose | Key Exports |
|--------|---------|-------------|
| `types.py` | Type definitions (50+) | `CLIAgentOptions`, `Message`, `AgentDefinition` |
| `config.py` | Environment settings | `CCFlowSettings` |
| `exceptions.py` | Error hierarchy (11) | `CCFlowError`, `CLITimeoutError` |

### Reliability & Limits
| Module | Purpose | Key Exports |
|--------|---------|-------------|
| `reliability.py` | Fault tolerance | `CircuitBreaker`, `retry_with_backoff()` |
| `rate_limiting.py` | Rate/concurrency control | `TokenBucketRateLimiter`, `CombinedLimiter` |
| `pool.py` | Concurrent execution | `ProcessPool`, `StreamingPool` |

### Project & Tracing
| Module | Purpose | Key Exports |
|--------|---------|-------------|
| `project.py` | Hierarchical organization | `Project` |
| `tracing.py` | Auto trace recording | `TracingSession` |
| `trace_store.py` | Store protocols | `TraceStore`, `ProjectStore` |

### Storage
| Module | Purpose | Key Exports |
|--------|---------|-------------|
| `stores/sqlite.py` | SQLite storage | `SQLiteSessionStore` |
| `stores/traces.py` | Trace storage | `SQLiteTraceStore`, `SQLiteProjectStore` |
| `stores/memory.py` | In-memory storage | `MemorySessionStore` |

### Observability
| Module | Purpose | Key Exports |
|--------|---------|-------------|
| `events.py` | Event pub/sub (18 types) | `EventEmitter`, `EventType` |
| `pricing.py` | Cost calculation | `calculate_cost()`, `ModelPricing` |
| `metrics_handlers.py` | Prometheus bridge | `PrometheusEventHandler` |

## Configuration (48 Fields)

### CLIAgentOptions
```python
CLIAgentOptions(
    # Model
    model="sonnet",              # haiku, sonnet, opus
    fallback_model="haiku",      # On overload

    # System prompt
    system_prompt=None,          # Replace system prompt
    append_system_prompt=None,   # Append to system prompt

    # Permissions
    permission_mode=PermissionMode.DEFAULT,
    allowed_tools=["Read", "Edit"],
    disallowed_tools=["Bash(rm:*)"],
    can_use_tool=my_callback,    # Permission callback (NEW)

    # Session
    session_id=None,
    resume=False,
    fork_session=False,

    # Limits
    max_turns=10,                # Turn limit (NEW)
    max_budget_usd=1.0,
    timeout=300.0,

    # Working directory
    cwd="/path/to/project",      # Working directory (NEW)

    # Extended thinking
    ultrathink=False,

    # Context
    context={"data": "value"},   # Auto-TOON encoded
    toon=ToonConfig(enabled=True),

    # MCP
    mcp_servers={"github": MCPServerConfig(...)},

    # Agent (NEW)
    agent="code-reviewer",       # Use specific agent
    agents={"custom": {...}},    # Custom agent definitions
)
```

## Message Types (15)

```python
Message = (
    InitMessage |           # Session initialization
    TextMessage |           # Text content from Claude
    ThinkingMessage |       # Extended thinking content
    ToolUseMessage |        # Tool invocation
    ToolResultMessage |     # Tool execution result
    ErrorMessage |          # Error from CLI
    StopMessage |           # Turn completion with usage
    HookMessage |           # Hook execution result
    AssistantMessage |      # Full assistant response
    UserMessage |           # User message echo
    ResultMessage |         # Final result
    UnknownMessage |        # Forward-compatible fallback
    UnknownSystemMessage    # System message fallback
)
```

## Event Types (18)

```python
EventType.SESSION_CREATED     # Session started
EventType.SESSION_RESUMED     # Session resumed
EventType.SESSION_CLOSED      # Session closed
EventType.SESSION_ERROR       # Session error
EventType.TURN_STARTED        # Turn began
EventType.TURN_COMPLETED      # Turn finished
EventType.THINKING_RECEIVED   # Thinking tokens
EventType.TOOL_CALLED         # Tool invocation
EventType.TOOL_RESULT         # Tool result
EventType.TOKENS_USED         # Token consumption
EventType.COST_INCURRED       # Cost tracked
EventType.SESSION_PERSISTED   # Session saved
EventType.SESSION_LOADED      # Session loaded
EventType.SESSION_DELETED     # Session deleted
```

## Exceptions (13)

```
CCFlowError (base)
├── CLINotFoundError         # Claude CLI not installed
├── CLIAuthenticationError   # OAuth not configured
├── CLIExecutionError        # CLI subprocess failed
├── CLITimeoutError          # Operation timed out
├── SessionNotFoundError     # Session doesn't exist
├── ParseError               # NDJSON parsing failed
├── ToonEncodingError        # TOON serialization failed
├── PermissionDeniedError    # Tool permission denied
├── MCPConfigError           # MCP config invalid
├── SessionStoreError        # Storage operation failed
├── CircuitBreakerError      # Circuit is open
├── RateLimitExceededError   # Rate limit hit
└── ConcurrencyLimitExceededError  # Max concurrent reached
```

## Design Patterns (10)

| Pattern | Implementation | Purpose |
|---------|----------------|---------|
| Singleton | `get_*()` / `reset_*()` | Global service instances |
| Registry | `AgentRegistry`, `HookRegistry` | Dynamic registration |
| Circuit Breaker | `CircuitBreaker` | Fault tolerance |
| Token Bucket | `TokenBucketRateLimiter` | Rate limiting |
| Observer | `EventEmitter`, `HookRegistry` | Event handling |
| Strategy | `can_use_tool` callback | Pluggable permissions |
| Facade | `query()`, `Session` | Simplified API |
| Template Method | Store protocols | Pluggable backends |
| Decorator | `@tool`, `@hooks.on()` | Functional decoration |
| Factory | `create_sdk_mcp_server()` | Object creation |

## Best Practices (Anthropic Guidelines)

### Session Management
- Clear session boundaries with `/clear`
- Use `CLAUDE.md` for environment instructions
- Track progress between sessions
- Git commit checkpoints for recovery

### Error Handling
- Graceful degradation with circuit breaker
- Retry with exponential backoff
- Proper exception hierarchies
- Transient error detection

### Observability
- Structured logging (structlog)
- Prometheus metrics integration
- Correlation IDs for tracing
- Event pub/sub system

### Token Optimization
- TOON encoding for context (30-60% savings)
- Efficient data structures
- Streaming responses
- Context management

## Testing

```bash
# Run all tests (1055+)
pytest tests/ -v

# With coverage
pytest tests/ --cov=ccflow --cov-report=term-missing

# Skip slow/integration
pytest tests/ -m "not slow and not integration"
```

## CLI Usage

```bash
# Basic query
ccflow "Explain this code"

# With model selection
ccflow -m opus "Review for security"

# Session management
ccflow sessions --list
ccflow sessions --resume <session-id>

# Start HTTP server
ccflow server --port 8080
```

## Links

- **API Docs**: docs/api.md
- **Architecture**: docs/architecture.md
- **TOON Spec**: docs/TOON_RESEARCH.md
- **Changelog**: CHANGELOG.md
